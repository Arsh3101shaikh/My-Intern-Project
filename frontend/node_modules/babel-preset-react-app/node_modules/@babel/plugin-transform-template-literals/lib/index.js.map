{"version":3,"names":["_helperPluginUtils","require","_core","_default","exports","default","declare","api","options","_api$assumption","_api$assumption2","assertVersion","ignoreToPrimitiveHint","assumption","loose","mutableTemplateObject","helperName","buildConcatCallExpressions","items","avail","reduce","left","right","canBeInserted","t","isLiteral","isCallExpression","arguments","push","callExpression","memberExpression","identifier","name","visitor","TaggedTemplateExpression","path","node","quasi","strings","raws","isStringsRawEqual","elem","quasis","raw","cooked","value","scope","buildUndefinedNode","stringLiteral","helperArgs","arrayExpression","tmp","generateUidIdentifier","getProgramParent","id","cloneNode","replaceWith","tag","template","expression","ast","addHelper","expressions","TemplateLiteral","parent","type","nodes","get","index","length","expr","isStringLiteral","unshift","root","i","binaryExpression"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { template, types as t, type NodePath } from \"@babel/core\";\n\nexport interface Options {\n  loose?: boolean;\n}\n\nexport default declare((api, options: Options) => {\n  api.assertVersion(REQUIRED_VERSION(7));\n\n  const ignoreToPrimitiveHint =\n    api.assumption(\"ignoreToPrimitiveHint\") ?? options.loose;\n  const mutableTemplateObject =\n    api.assumption(\"mutableTemplateObject\") ?? options.loose;\n\n  let helperName = \"taggedTemplateLiteral\";\n  if (mutableTemplateObject) helperName += \"Loose\";\n\n  /**\n   * This function groups the objects into multiple calls to `.concat()` in\n   * order to preserve execution order of the primitive conversion, e.g.\n   *\n   *   \"\".concat(obj.foo, \"foo\", obj2.foo, \"foo2\")\n   *\n   * would evaluate both member expressions _first_ then, `concat` will\n   * convert each one to a primitive, whereas\n   *\n   *   \"\".concat(obj.foo, \"foo\").concat(obj2.foo, \"foo2\")\n   *\n   * would evaluate the member, then convert it to a primitive, then evaluate\n   * the second member and convert that one, which reflects the spec behavior\n   * of template literals.\n   */\n  function buildConcatCallExpressions(items: t.Expression[]): t.CallExpression {\n    let avail = true;\n    // @ts-expect-error items must not be empty\n    return items.reduce(function (left, right) {\n      let canBeInserted = t.isLiteral(right);\n\n      if (!canBeInserted && avail) {\n        canBeInserted = true;\n        avail = false;\n      }\n      if (canBeInserted && t.isCallExpression(left)) {\n        left.arguments.push(right);\n        return left;\n      }\n      return t.callExpression(\n        t.memberExpression(left, t.identifier(\"concat\")),\n        [right],\n      );\n    });\n  }\n\n  return {\n    name: \"transform-template-literals\",\n\n    visitor: {\n      TaggedTemplateExpression(path) {\n        const { node } = path;\n        const { quasi } = node;\n\n        const strings = [];\n        const raws = [];\n\n        // Flag variable to check if contents of strings and raw are equal\n        let isStringsRawEqual = true;\n\n        for (const elem of quasi.quasis) {\n          const { raw, cooked } = elem.value;\n          const value =\n            cooked == null\n              ? path.scope.buildUndefinedNode()\n              : t.stringLiteral(cooked);\n\n          strings.push(value);\n          raws.push(t.stringLiteral(raw));\n\n          if (raw !== cooked) {\n            // false even if one of raw and cooked are not equal\n            isStringsRawEqual = false;\n          }\n        }\n\n        const helperArgs = [t.arrayExpression(strings)];\n        // only add raw arrayExpression if there is any difference between raws and strings\n        if (!isStringsRawEqual) {\n          helperArgs.push(t.arrayExpression(raws));\n        }\n\n        const tmp = path.scope.generateUidIdentifier(\"templateObject\");\n        path.scope.getProgramParent().push({ id: t.cloneNode(tmp) });\n\n        path.replaceWith(\n          t.callExpression(node.tag, [\n            template.expression.ast`\n              ${t.cloneNode(tmp)} || (\n                ${tmp} = ${this.addHelper(helperName)}(${helperArgs})\n              )\n            `,\n            // @ts-expect-error Fixme: quasi.expressions may contain TSAnyKeyword\n            ...quasi.expressions,\n          ]),\n        );\n      },\n\n      TemplateLiteral(path) {\n        if (path.parent.type === \"TSLiteralType\") {\n          // Skip TemplateLiteral in TSLiteralType\n          return;\n        }\n        const nodes: t.Expression[] = [];\n        const expressions = path.get(